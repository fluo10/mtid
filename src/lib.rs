//! A human-friendly 7 characters identifier format (e.g. `123abcd`).
//!
//! For a language agnostic specification of the caretta-id format, see [SPECS.md](https://github.com/fluo10/caretta-id/blob/main/SPECS.md)
//!
//! # Quick Start
//!
#![cfg_attr(feature = "default", doc = "```rust")]
#![cfg_attr(not(feature = "default"), doc = "```ignore")]
//! use caretta_id::CarettaId;
//!
//! let id = CarettaId::random();
//! println!("{}", id); // e.g. "123abcd"
//! ```
//!
//! # Why caretta-id?
//!
//! Traditional identifier systems face challenges in distributed environments:
//!
//! - **Sequential numbers** (like GitHub issue numbers) cause collisions in distributed systems
//! - **UUIDs** are too long and not human-friendly
//! - **Short hashes** (like Git commit hashes) lack standardization
//!
//! caretta-id bridges the gap between human readability and technical requirements.
//!
//! # Installation
//!
//! Add this to your `Cargo.toml`:
//!
//! ```toml
//! [dependencies]
//! caretta-id = "0.9"
//!
//! # With optional features
//! caretta-id = { version = "0.9", features = ["arbitrary", "serde", "rusqlite", "sea-orm", "prost", "redb"] }
//! ```
//!
//! ## For no_std Environments
//!
//! This crate support `no_std`.
//! For `no_std` environment, you'll need to disable default features.
//!
//! ```toml
//! [dependencies]
//! caretta-id = { version = "0.9", default-features = false }
//! ```
//!
//! # Features
//!
//! - **Human-friendly**: Easy to read, type, and communicate
//! - **Collision-resistant**: Sufficient entropy for personal distributed systems
//! - **Compact**: Shorter than UUIDs while maintaining uniqueness
//! - **Type-safe**: Rust implementation with strong typing
//! - **Multiple integrations**: Support for serde, rusqlite, sea-orm, and protobuf
//!
//! ## Optional Feature Flags
//!
//! - `arbitrary`: `arbitrary::Arbitrary` support for fuzzing tests.
//! - `serde`: Serialization/deserialization support
//! - `rusqlite`: SQLite database integration
//! - `sea-orm`: SeaORM ORM integration  
//! - `prost`: Protocol Buffers support
//! - `redb`: `redb` integration
//!
//! # Examples
//!
#![cfg_attr(feature = "default", doc = "```rust")]
#![cfg_attr(not(feature = "default"), doc = "```ignore")]
//! use caretta_id::CarettaId;
//! # fn main() -> Result<(), caretta_id::Error> {
//! // Generate random caretta-id
//! let caretta_id = CarettaId::random();
//!
//! // e.g. `123abcd`
//! println!("'{}'", caretta_id);
//!
//! // Parse from string
//! let valid_id: CarettaId = "012atvw".parse()?;
//!
//! // When decoding from BASE32, ambiguous characters (1/l/I, 0/o, v/u) are treated as 1, 0 and v respectively, so they do not cause errors.
//! let also_valid_id: CarettaId = "ol2atuw".parse()?;
//! assert_eq!(valid_id, also_valid_id);
//!
//! // Convert to/from integer
//! let num: u64 = valid_id.into();
//! let id_from_int: CarettaId = num.try_into()?;
//! assert_eq!(valid_id, id_from_int);
//!
//! // Lossy conversion from oversized int is allowed.
//! let id_from_overflowed_int = CarettaId::from_u64_lossy(CarettaId::CAPACITY + num);
//! assert_eq!(valid_id, id_from_overflowed_int);
//!
//! # Ok(())
//! # }
//! ```
#![cfg_attr(not(feature = "std"), no_std)]
#![cfg_attr(docsrs, feature(doc_cfg))]

#[cfg(all(not(feature = "std"), not(test)))]
#[macro_use]
extern crate core as std;

/// Provides constants and private functions about encoding/decoding alphabet.
///
/// This module implements encoding and decoding character based on [Crockford's Base32](https://www.crockford.com/base32.html) with following exceptions:
///
/// - The letter `u` (`U`) is decoded to 27, same as `v`.
/// - Characters are separated by hyphens every three characters (triplet) during encoding.
///   During decoding, hyphens may be omitted or replaced with underscores.
pub mod alphabet;
mod caretta_id;
mod double;
mod error;
mod macros;
mod quadruple;
mod single;
mod triple;

#[cfg(feature = "arbitrary")]
mod arbitrary;

#[cfg(feature = "rand")]
mod rand;

#[cfg(feature = "serde")]
mod serde;

#[cfg(feature = "prost")]
mod prost;

#[cfg(feature = "redb")]
mod redb;

#[cfg(feature = "rusqlite")]
mod rusqlite;

#[cfg(feature = "sea-orm")]
mod sea_orm;

/// Provides [`Triplet`](triplet::Triplet) and [`TripletError`](triplet::TripletError).
#[deprecated(since = "0.8.1")]
pub mod triplet;

pub use caretta_id::CarettaId;
pub use double::CarettaIdD;
pub use error::Error;
pub use quadruple::CarettaIdQ;
pub use single::CarettaIdS;
pub use triple::CarettaIdT;

use crate::alphabet::{BASE, char_to_u5, u5_to_char_lossy};
use macros::{doc_from_bytes, doc_from_bytes_lossy, doc_to_bytes};

/// Provides message types generated by prost-build.
#[cfg(feature = "prost")]
pub mod proto;

/// Alias of [`proto::CarettaIdS`]
#[cfg(feature = "prost")]
#[deprecated(
    since = "0.8.1",
    note = "The caretta-id has been renewed. Use new CarettaId instead."
)]
pub type CarettaIdSProto = proto::CarettaIdS;

/// Alias of [`proto::CarettaIdD`]
#[cfg(feature = "prost")]
#[deprecated(
    since = "0.8.1",
    note = "The caretta-id has been renewed. Use new CarettaId instead."
)]
pub type CarettaIdDProto = proto::CarettaIdD;

/// Alias of [`proto::CarettaIdT`]
#[cfg(feature = "prost")]
#[deprecated(
    since = "0.8.1",
    note = "The caretta-id has been renewed. Use new CarettaId instead."
)]
pub type CarettaIdTProto = proto::CarettaIdT;

/// Alias of [`proto::CarettaIdQ`]
#[cfg(feature = "prost")]
#[deprecated(
    since = "0.8.1",
    note = "The caretta-id has been renewed. Use new CarettaId instead."
)]
pub type CarettaIdQProto = proto::CarettaIdQ;

/// Alias of [`proto::CarettaId`]
#[cfg(feature = "prost")]
pub type CarettaIdProto = proto::CarettaId;
